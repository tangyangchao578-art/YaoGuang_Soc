#!/usr/bin/env python3
"""
AXI接口生成器

生成AXI总线接口模板代码，帮助快速开始前端IP设计。

使用方法：
    python axi_gen.py --name <module_name> --data_width <width> --addr_width <width>

示例：
    python axi_gen.py --name dma_controller --data_width 64 --addr_width 32
"""

import argparse
from pathlib import Path


def generate_axi_master_template(name: str, data_width: int, addr_width: int) -> str:
    """生成AXI Master接口模板。"""
    template = f"""// AXI4 Master Interface - {name}
// Generated by chip-frontend-design skill

`timescale 1ns/1ps

module {name}_axi_master #(
    input  wire                      clk,
    input  wire                      rst_n,
    // Write Address Channel
    output wire [{addr_width-1}:0]   m_awid,
    output wire [{addr_width-1}:0]   m_awaddr,
    output wire [6:0]               m_awlen,
    output wire [1:0]               m_awsize,
    output wire [1:0]               m_awburst,
    output wire [1:0]               m_awlock,
    output wire [3:0]               m_awcache,
    output wire [2:0]               m_awprot,
    output wire [3:0]               m_awqos,
    output wire [{data_width-1}:0]   m_wdata,
    output wire [{data_width}/8-1:0]  m_wstrb,
    output wire                      m_wlast,
    output wire                      m_wvalid,
    input  wire                      m_wready,
    // Write Response Channel
    input  wire [0:0]               m_bid,
    input  wire [1:0]               m_bresp,
    input  wire                      m_bvalid,
    // Read Address Channel
    output wire [{addr_width-1}:0]   m_arid,
    output wire [{addr_width-1}:0]   m_araddr,
    output wire [6:0]               m_arlen,
    output wire [1:0]               m_arsize,
    output wire [1:0]               m_arburst,
    output wire [1:0]               m_arlock,
    output wire [3:0]               m_arcache,
    output wire [2:0]               m_arprot,
    output wire [3:0]               m_arqos,
    output wire                      m_arvalid,
    input  wire                      m_arready,
    // Read Data Channel
    input  wire [0:0]               m_rid,
    input  wire [{data_width-1}:0]   m_rdata,
    input  wire [1:0]               m_rresp,
    input  wire                      m_rlast,
    input  wire                      m_rvalid,
    output wire                      m_rready
);

// TODO: Add your custom logic here

endmodule
"""
    return template


def generate_axi_slave_template(name: str, data_width: int, addr_width: int) -> str:
    """生成AXI Slave接口模板。"""
    template = f"""// AXI4 Slave Interface - {name}
// Generated by chip-frontend-design skill

`timescale 1ns/1ps

module {name}_axi_slave #(
    input  wire                      clk,
    input  wire                      rst_n,
    // Write Address Channel
    input  wire [{addr_width-1}:0]   s_awid,
    input  wire [{addr_width-1}:0]   s_awaddr,
    input  wire [6:0]               s_awlen,
    input  wire [1:0]               s_awsize,
    input  wire [1:0]               s_awburst,
    input  wire [1:0]               s_awlock,
    input  wire [3:0]               s_awcache,
    input  wire [2:0]               s_awprot,
    input  wire [3:0]               s_awqos,
    input  wire [{data_width-1}:0]   s_wdata,
    input  wire [{data_width}/8-1:0]  s_wstrb,
    input  wire                      s_wlast,
    input  wire                      s_wvalid,
    output wire                      s_wready,
    // Write Response Channel
    output wire [0:0]               s_bid,
    output wire [1:0]               s_bresp,
    output wire                      s_bvalid,
    // Read Address Channel
    input  wire [{addr_width-1}:0]   s_arid,
    input  wire [{addr_width-1}:0]   s_araddr,
    input  wire [6:0]               s_arlen,
    input  wire [1:0]               s_arsize,
    input  wire [1:0]               s_arburst,
    input  wire [1:0]               s_arlock,
    input  wire [3:0]               s_arcache,
    input  wire [2:0]               s_arprot,
    input  wire [3:0]               s_arqos,
    input  wire                      s_arvalid,
    output wire                      s_arready,
    // Read Data Channel
    output wire [{data_width-1}:0]   s_rid,
    output wire [{data_width-1}:0]   s_rdata,
    output wire [1:0]               s_rresp,
    output wire                      s_rlast,
    output wire                      s_rvalid,
    input  wire                      s_rready
);

// TODO: Add your custom logic here

endmodule
"""
    return template


def generate_uvm_scoreboard_template(name: str, data_width: int) -> str:
    """生成UVM Scoreboard模板。"""
    strb_width = data_width // 8
    template = f"""// UVM Scoreboard for {name}
// Generated by chip-frontend-design skill

`include "uvm_macros.svh"
`include "uvm_object.svh"

class {name}_scoreboard extends uvm_scoreboard;

  // Transaction type
  typedef struct {{
    bit [{data_width-1}:0] data;
    bit [{strb_width-1}:0] strb;
    bit                        last;
    bit [1:0]                  id;
  }} {name}_trans_t;

  // Analysis port
  uvm_analysis_imp #({name}_trans_t) item_collected_port;

  // Reference model (compare against)
  virtual function bit compare(ref_item: {name}_trans_t);
  virtual function void report_summary();

  // Expected and actual queues
  {name}_trans_t expected_queue[$];
  {name}_trans_t actual_queue[$];

  function new(string name = "{name}_scoreboard");
    super.new(name);
    item_collected_port = new("item_collected_port");
  endfunction

  virtual function void write(input {name}_trans_t trans);
    // Add transaction to scoreboard
    void'($sformatf("Item received: data=0x%h, strb=0x%h",
                 trans.data, trans.strb));
    item_collected_port.write(trans);
  endfunction

  virtual function bit check();
    // Compare expected vs actual
    if (expected_queue.size() != 0 && actual_queue.size() != 0) begin
      {name}_trans_t expected;
      {name}_trans_t actual;
      expected = expected_queue.pop_front();
      actual = actual_queue.pop_front();

      if (expected.data != actual.data ||
          expected.strb != actual.strb ||
          expected.last != actual.last ||
          expected.id != actual.id) begin
        `uvm_error("Mismatch! Expected: 0x%h, Actual: 0x%h",
                  expected.data, actual.data);
        return 0;
      end
    end
    return 1;
  endfunction

  virtual function void report_summary();
    `uvm_info("Scoreboard Summary:");
    `uvm_info("  Expected items: %0d", expected_queue.size());
    `uvm_info("  Actual items:   %0d", actual_queue.size());
    if (expected_queue.size() == actual_queue.size()) begin
      `uvm_info("  All items matched!");
    end
  endfunction

endclass
"""
    return template


def generate_axi_test_template(name: str, data_width: int) -> str:
    """生成AXI接口测试用例模板。"""
    strb_width = data_width // 8
    template = f"""// AXI Testbench for {name}
// Generated by chip-frontend-design skill

`include "uvm_macros.svh"
`include "uvm_pkg.sv"
`include "{name}_scoreboard.sv"

module {name}_tb;

  // Clock and Reset
  reg clk;
  reg rst_n;

  // AXI Interface
  {name}_axi_master axi_if();

  // Test signals
  reg [31:0]  write_addr;
  reg [63:0]  write_data;
  reg         write_valid;
  reg [31:0]  read_addr;
  reg         read_valid;
  reg [63:0]  read_data;

  // Scoreboard
  {name}_scoreboard sb;

  initial begin
    // Clock generation
    clk = 0;
    forever #5 clk = ~clk;

    // Reset sequence
    rst_n = 0;
    #100 rst_n = 1;

    // Build UVM environment
    `uvm_info("Starting AXI Testbench");

    // TODO: Add test sequences here
    // - Basic write/read tests
    // - Burst transfer tests
    // - Error injection tests
    // - Back-to-back transactions
  end

endmodule
"""
    return template


def main():
    parser = argparse.ArgumentParser(
        description="AXI接口代码生成器",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument("--name", required=True, help="模块名称")
    parser.add_argument("--data_width", type=int, default=32, help="数据位宽（默认32）")
    parser.add_argument("--addr_width", type=int, default=32, help="地址位宽（默认32）")
    parser.add_argument("--type", choices=["master", "slave", "test"], help="生成类型")
    parser.add_argument("--output", help="输出文件路径")

    args = parser.parse_args()

    if args.type == "master":
        content = generate_axi_master_template(args.name, args.data_width, args.addr_width)
        filename = f"{args.name}_axi_master.sv"
    elif args.type == "slave":
        content = generate_axi_slave_template(args.name, args.data_width, args.addr_width)
        filename = f"{args.name}_axi_slave.sv"
    elif args.type == "test":
        content = generate_axi_test_template(args.name, args.data_width)
        filename = f"{args.name}_tb.sv"
    else:
        # Generate both interfaces and scoreboard
        content = f"""// AXI Interfaces for {name}
// Generated by chip-frontend-design skill

{generate_axi_master_template(args.name, args.data_width, args.addr_width)}

{generate_axi_slave_template(args.name, args.data_width, args.addr_width)}

{generate_uvm_scoreboard_template(args.name, args.data_width)}
"""
        filename = f"{args.name}_axi_all.sv"

    if args.output:
        output_path = Path(args.output) / filename
        output_path.parent.mkdir(parents=True, exist_ok=True)
        output_path.write_text(content, encoding="utf-8")
        print(f"Generated: {output_path}")
    else:
        print(content)


if __name__ == "__main__":
    main()
